通过Pygame Zero学习编程
==================================

万丈高楼平地起.本教程面相任何零编程经验人员.接下来我们会做一个简单但非常有趣的游戏.

我假设你安装了Pygame Zero, 并且晓得如何使用文本编辑器.

新建一个空白文件
----------------

首先,通过你的编辑器新建一个名为 "fishfrenzy.py" 的空白文件并把 "fishfrenzy.py" 
保存到新的目录.

通过运行下面的命令确认空白文件运行并且创建了空白窗口::

    cd the_directory_you_created
    pgzrun fishfrenzy.py

\如何运行取决于你的编辑器,shell或者你加载的其他插件.

如果运行失败,有可能是因为你的文件路径错了, Python或者Pygame Zero没有正确安装,以及各种
千奇百怪的原因.从某种意义上讲,第一步是最难迈出的,但是这已经超过了这篇教程的范围,取决于
很多不同配置,比如你的操作系统, 你python的版本,你Pygame的版本等等.

如果你的代码运行那你的运气可真不错!如果你看到一个空白的 "Pygame Zero Game" 创客,我们就
就可以进行下一步了.

真的是运气吗?
-------------

你可以在下面的聊天室获得帮助,或者添加微信ilangxm, 备注pygame zero我会拉你入群

http://webchat.freenode.net?randomnick=1&channels=%23%23learnpython&uio=d4

函数
----------

让我们正式开始吧.

对大部分大部分编程语言来,编程就是定义一系列计算机可以执行的步骤,就像是 **菜谱**. 在烹饪
里,你可能有下列菜谱:

    **蛋糕菜谱**

    * 碗里家店面
    * 碗里加点糖
    * 碗里加点奶油
    * 碗里加一个鸡蛋
    * 快速搅拌
    * 把碗里的东东导入蛋糕模子
    * 烘烤

... 等等,当然按照这个菜谱大概是做不出蛋糕的,因为我不是厨子啊

程序设计人员中的游戏就是如何把这些看做一个程序,并且在一个能够理解你定义的任意指令的
虚拟计算机中运行.这叫做 **伪代码** 因为看起来像代码,但实际上不能运行.如果我们把菜谱
翻译成Python程序,就会像这样::

    def cake_recipe():
        bowl.add(flour)
        bowl.add(sugar)
        bowl.add(butter)
        bowl.add(egg)
        whisk(bowl)
        cake_tin.add(bowl.get_contents())
        bake(cake_tin)

伪代码和Python代码很相似.虽然我们用一些特殊的方式拼写单词,但总体上Python和伪代码的每一
行都是等价的 - 都是一个 "动作" 或者说 "行为" .

第一行中的 ``def`` 定义了一个叫做 ``cake_recipe`` 的菜谱, 其他代码是菜谱的步骤.都用
parentheses,表示他们只想计算机可能知道的其他菜谱.

让我们用Pygame Zero写一个真正的食谱. 在你的编辑器里,让我们写一个 ``draw`` 食谱.Pygame
可以正确的调用名为 ``draw`` 的函数::


    def draw():
        screen.clear()

        screen.draw.circle((400, 300), 30, (255, 255, 255))

用一下命令运行::

    pgzrun fishfrenzy.py

你的代码运行了吗? 看到一个圆圈没?我的电脑看上去是:

.. image:: _static/grabs/circle.png

如果Pygame Zero没有创建窗口,或者出现了一个窗口然后闪退, 看下出现的错误提示:

* ``SyntaxError`` - 语法错误,意味着你可能漏掉了一个括号,或者缩进跟我的代码有区别.注意
  函数的每一行必须对齐, 但是必须比顶部的 ``def`` 缩进 **多一些**
* ``AttributeError`` or ``NameError`` - 属性或者名称错误, 你可能有拼写错误.
* ``TypeError`` - 类型错误,是不是有的括号位置错了?

如果窗口出现了,但是窗口啥都不显示,检查下 "draw" 是不是拼错了? 或者数字有没有写错?

如果代码一开始就不能运行,仔细检查下你的代码,多尝试几次代码就能正常运行了.

我们定义了一个包含两个步骤的食谱:

1. 清空屏幕,让屏幕显示黑色
2. 在屏幕上画个圈圈:

    * ``(400, 300)`` 是圆心坐标, 用距离屏幕左上角的坐标数表示.
    * 半径是 ``30`` 像素
    * 圆的轮廓是白色的,用仨数表示, 分别表示红绿蓝
      的值 ``(255, 255, 255)``. 白色是红,绿和蓝的混合色. ``255`` 是颜色的最大值.

你可以 **尝试改变这三个值**,运行程序并查看效果.


进阶:本地和全局变量
-------------------------------------

建设我们写了如下代码::

    RED = 150, 0, 0
    GREEN = 0, 128, 0

    bg = RED

    def draw():
        screen.fill(bg)

    def on_mouse_down():
        bg = GREEN

    def on_mouse_up():
        bg = RED

有的语言中,这样写没有问题的: 当单击屏幕的时候屏幕是绿色,松开鼠标按钮,屏幕变成红色.

但是在Python中是不行的.如果你试着运行这段代码,你就会发现屏幕不会变成绿色.为啥捏?

当你在函数内部像第10行一样用 ``==`` 进行赋值操作的时候, 你就新建了一个仅仅在函数内部
存在的bg变量. 我们想修改的 ``bg`` 是全局变量, 这实际上是一个非常明智的做法,你不想...

解决办法是在 ``on_mouse_down`` 和 ``on_mouse_up`` 函数中明确的表示我们是想修改全局
变量,而不是新建一个本地变量. 我们用 ``global`` 声明来完成这个目标. 正确的Pygame Zero
代码如下::

    RED = 150, 0, 0
    GREEN = 0, 128, 0

    bg = RED

    def draw():
        screen.fill(bg)

    def on_mouse_down():
        global bg
        bg = GREEN

    def on_mouse_up():
        global bg
        bg = RED

网易少儿编程郎郎老师翻译, 微信 ilangxm